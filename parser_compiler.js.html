<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: parser/compiler.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: parser/compiler.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Methods for compiling the DNA AST into executable javascript.
 * @module Parser/Compiler
 **/

var Ast    = require('./ast.js'),
    Result = require('object-result'),
    Ok     = Result.Ok,
    Err    = Result.Err;

/**
 * @callback DnaCallback
 * @param {Object} sysvars - Object describing the Bot's sysvars.
 **/

/**
 * Compiles the dna node into a single executable function.
 * The returned function accepts an object representing the
 * bot's state.
 * @param {Object} dnaNode - Ast Node generated by the Ast.createDna function.
 * @return {DnaCallback} A function which takes a 'sysvars' object.
 **/
module.exports = function(dnaNode) {
  var geneFuncs = dnaNode.genes.map(function(gene, index) {
    return compileGene(gene);
  });

  return function(sysvars) {
    geneFuncs.forEach(function(gene) {
      gene(sysvars);
    });
  };
};

/**
 * Compiles genes into executable functions.
 * @param {Object} gene - Gene Node.
 * @return {DnaCallback} a function which takes a 'sysvars' object.
 **/
var compileGene = function(gene) {
  var bodyExprFuncs = gene.bodyExpressions.map(function(bodyExpression) {
    return compileBodyExpression(bodyExpression);
  });

  if (gene.condExpression.type === 'EmptyCond') {
    return function(sysvars) {
      bodyExprFuncs.forEach(function(bodyExprFunc) {
        bodyExprFunc(sysvars);
      });
    };
  }

  var condExprFunc = compileCondExpression(gene.condExpression);

  return function(sysvars) {
    if (condExprFunc(sysvars) === true) {
      bodyExprFuncs.forEach(function(bodyExprFunc) {
        bodyExprFunc(sysvars);
      });
    }
  };
};

/**
 * Switches on the type of node provided in order to execute the proper
 * compile method.
 * @param {Object} condExpr - Ast Node representing part of a conditional
 *                            expression.
 * @return {DnaCallback}
 **/
var compileCondExpression = function(condExpr) {
  switch (condExpr.type) {
    case 'AndPhrase':
    case 'OrPhrase':
      return compilePhrase(condExpr);

    case 'EqualExpr':
    case 'LessExpr':
    case 'GreaterExpr':
    case 'GEExpr':
    case 'LEExpr':
    case 'NEExpr':
      return compileBoolExpr(condExpr);

    default:
      return compileExprNode(condExpr);
  }
};

/**
 * Compiles a Boolean expression node into a DnaCallback.
 * @param {Object} condExpr - Boolean expression node.
 * @return {DnaCallback}
 **/
var compileBoolExpr = function(condExpr) {
  var exp1 = compileCondExpression(condExpr.exp1);
  var exp2 = compileCondExpression(condExpr.exp2);

  switch (condExpr.type) {
    case 'EqualExpr':
      return function(sysvars) { return exp1(sysvars) === exp2(sysvars); };
    case 'LessExpr':
      return function(sysvars) { return exp1(sysvars) &lt; exp2(sysvars); };
    case 'GreaterExpr':
      return function(sysvars) { return exp1(sysvars) > exp2(sysvars); };
    case 'GEExpr':
      return function(sysvars) { return exp1(sysvars) >= exp2(sysvars); };
    case 'LEExpr':
      return function(sysvars) { return exp1(sysvars) &lt;= exp2(sysvars); };
    case 'NEExpr':
      return function(sysvars) { return exp1(sysvars) !== exp2(sysvars); };
  }
};

/**
 * Compiles a phrase node (AndPhrase or OrPhrase) into a DnaCallback.
 * @param {Object} condExpr - Conditional expression node.
 * @return {DnaCallback}
 **/
var compilePhrase = function(condExpr) {
  var lhs = compileCondExpression(condExpr.lhs);
  var rhs = compileCondExpression(condExpr.rhs);

  if (condExpr.type === 'AndPhrase') {
    return function(sysvars) {
      return lhs(sysvars) &amp;&amp; rhs(sysvars);
    };
  } else {
    return function(sysvars) {
      return lhs(sysvars) || rhs(sysvars);
    };
  }
};

/**
 * Compiles a bodyExpression into an executable function.
 * @param {Object} bodyExpr - Node representing a body expression.
 * @return (DnaCallback) a function which takes a 'sysvars' object.
 **/
var compileBodyExpression = function(bodyExpr) {
  var variableName = bodyExpr.variable.name;
  var expression   = compileExprNode(bodyExpr.expression);

  return function(sysvars) {
    sysvars[variableName] = expression(sysvars);
  };
};

/**
 * Compiles the node into function using the node's type to determine
 * how to compile.
 * @param {Object} node - The node to compile.
 * @return {DnaCallback} a function which takes a 'sysvars' object.
 **/
var compileExprNode = function(node) {
  switch (node.type) {
    case 'DivExpr':
    case 'MulExpr':
    case 'AddExpr':
    case 'SubExpr':
    case 'PowExpr':
      return compileExpression(node);

    case 'Minus':
      return compileMinus(node);

    case 'Variable':
      return compileVariable(node);

    case 'Number':
      return function(sysvars) {
        return node.value;
      };
  }
};

/**
 * Compiles a negation node into a DnaCallback.
 * @param {Object} node - Should be a group node.
 * @return {DnaCallback}
 **/
var compileMinus = function(node) {
  var unary = compileExprNode(node.unary);

  return function(sysvars) {
    return -unary(sysvars);
  };
};

/**
 * Compiles a variable node into a DnaCallback.
 * @param {Object} variable - variable node.
 * @return {DnaCallback}
 **/
var compileVariable = function(variable) {
  var name = variable.name;

  if (name === 'rnd') {
    return function(sysvars) {
      return Math.random() * sysvars.rnd;
    };
  }

  return function(sysvars) {
    return sysvars[name] || 0;
  };
};

/**
 * Compiles an expression node (Add, Div, etc...) into a DnaCallback.
 * @param {Object} node - Expression Node (should be either Div, Mul,
 *                        Add, or Sub expr).
 * @return {DnaCallback}
 **/
var compileExpression = function(node) {
  var term1 = compileExprNode(node.term1);
  var term2 = compileExprNode(node.term2);

  switch (node.type) {
    case 'DivExpr':
      return function(sysvars) {
        return term1(sysvars) / term2(sysvars);
      };

    case 'MulExpr':
      return function(sysvars) {
        return term1(sysvars) * term2(sysvars);
      };

    case 'AddExpr':
      return function(sysvars) {
        return term1(sysvars) + term2(sysvars);
      };

    case 'SubExpr':
      return function(sysvars) {
        return term1(sysvars) - term2(sysvars);
      };

    case 'PowExpr':
      return function(sysvars) {
        return Math.pow(term1(sysvars), term2(sysvars));
      };
  }
};














</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-DarwinBots.html">DarwinBots</a></li><li><a href="module-Parser.html">Parser</a></li><li><a href="module-Parser_Ast.html">Parser/Ast</a></li><li><a href="module-Parser_Compiler.html">Parser/Compiler</a></li><li><a href="module-Parser_Parser.html">Parser/Parser</a></li><li><a href="module-Parser_SourceManager.html">Parser/SourceManager</a></li><li><a href="module-Simulation.html">Simulation</a></li><li><a href="module-Simulation_Bot.html">Simulation/Bot</a></li><li><a href="module-Simulation_Rules.html">Simulation/Rules</a></li><li><a href="module-Simulation_Species.html">Simulation/Species</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Wed Sep 30 2015 07:12:49 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
