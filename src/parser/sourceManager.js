var Result = require('object-result'),
    Ok     = Result.Ok,
    Err    = Result.Err;

/**
 * Strips comments out of the source code and replaces them
 * with whitespace. This keeps the cursor and line numbers
 * correct, but prevents us from having to parse these lines.
 **/
var stripComments = function(source) {
  var commentMatcher = /('(.*)\n)/g;

  return source.replace(commentMatcher, function(match) {
    return (new Array(match.length)).join(' ') + '\n';
  });
};

/**
 * Searches for newline indicators in the line given.
 * Returns a tuple containing the number of lines in the string, and the index
 * of the character at the beginning of the most recent line (indexOfLastLine).
 * @param {String} line - The line to search for newline chars.
 * @return {Object} { lineCount, indexOfLastLine }
 **/
var processNewline = function(line) {
  var newlineMatcher = /[\n\r]/;
  var lineCount = 0, lastLine = 0;

  var lineResults = line.match(newlineMatcher);

  while (lineResults) {
    lineCount++;
    lastLine += lineResults.index + 1;

    lineResults = line.slice(lastLine).match(newlineMatcher);
  }

  return { lineCount : lineCount, indexOfLastLine : lastLine };
};

/**
 * Creates a new SourceManager instance.
 * The SourceManager helps with parsing source code by keeping track of how far
 * through the code we have parsed (using the cursor) and what line we are
 * currently on. Helper methods are provided for skipping whitespace, and
 * matching keywords.
 **/
module.exports = function(rawSource) {
  var whitespaceMatcher = /(\s+)/;
  var cleanSource = stripComments(rawSource);

  return {
    src        : cleanSource,  // Source code, represented as a single string
    cursor     : 0,            // Current location in the code, used by the parser
    lineStart  : 0,            // Cursor location where the current line started
    line       : 1,            // Current line-count
    parenCtr   : 0,            // Tracks unclosed parens -- useful for redundancy
    insideGene : 0,            // Flag, tracks if the gene has been completed

    /**
     * Peek at the current character.
     * @return the character under the cursor, does not modify the source or cursor.
     **/
    peek : function() {
      return this.src[this.cursor];
    },

    /**
     * Skips whitespace until reaching a non-whitespace character,
     * then returns that character.
     * @return {String} The next non-whitespace character.
     **/
    next : function() {
      this.eatWhitespace();

      return this.peek();
    },

    /**
     * Attempts to match a key against the next non-whitespace characters.
     * Returns a Result object. Ok value is the string that was matched,
     * the Err object contains an error string generated by errAtCursor.
     * If Ok is returned then the cursor is automatically incremented
     * by the length of the matched string.
     * @param {Regex} key - The key to match against.
     * @param {String} errName - The name to use in an error message.
     * @return {Object} Result object containing Ok string or Err message.
     **/
    expect : function(key, errName) {
      this.eatWhitespace();

      var slice = this.src.slice(this.cursor);
      var results = slice.match(key);
      if (!results || results.index !== 0) {
        return Err(
          this.errAtCursor("Expected to find " + (errName || key.toString()))
        );
      }

      this.cursor += results[0].length;

      return Ok( results[0] );
    },

    /**
     * Similar to expect this attempts to match a key against the next
     * non-whitespace characters. However, Ok is returned when the match
     * is _not_ found, and Err is returned if a match is found.
     * Ok is empty, Err contains an error message constructed with the
     * errName.
     * The cursor is never updated.
     * @param {Regex} key - The key to match against.
     * @param {String} errName - The name to use in the error message.
     * @return {Object} Result object containing empty Ok or Err with message
     **/
    expectNot : function(key, errName) {
      this.eatWhitespace();

      var slice = this.src.slice(this.cursor);
      var results = slice.match(key);
      if (results && results.index === 0) {
        return Err( this.errAtCursor("Unexpected " + errName) );
      }

      return Ok();
    },

    /**
     * Reads all of the whitespace after the cursor and increments the
     * cursor to point to the next non-whitespace character. Records
     * newlines as they are passed, incrementing the line counter.
     **/
    eatWhitespace : function() {
      var currentSlice = this.src.slice(this.cursor);

      var results = currentSlice.match(whitespaceMatcher);
      if (results && results.index === 0) {
        var newLineDesc = processNewline(results[0]);

        this.line += newLineDesc.lineCount;
        if (newLineDesc.lineCount > 0) {
          this.lineStart = this.cursor + newLineDesc.indexOfLastLine;
        }

        this.cursor += results[0].length;
      }
    },

    /**
     * Returns a string with the current line's text and a carrot under
     * the location of the cursor. Assumes that the string will be displayed
     * with a monospace font.
     * The error string is displayed below the carrot.
     * @param {String} err - The error string to display below the carrot.
     * @return {String} Current line and carrot.
     **/
    errAtCursor : function(err) {
      var nextNewLine = this.src.length;
      var results = this.src.slice(this.cursor).match(/[\n\r]/);
      if (results) {
        nextNewLine = this.cursor + results.index;
      }

      var line = this.src.slice(this.lineStart, nextNewLine) + "\n";
      var errLen = this.cursor - this.lineStart;
      var errDesc = "Error on line " + this.line + " : " + (errLen + 1) + "\n";

      return errDesc + line + (new Array(errLen)).join(' ') + '^\n' + err;
    }
  };
};













